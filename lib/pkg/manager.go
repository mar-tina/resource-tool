package manager

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"

	"github.com/mar-tina/resource-tool/lib/schema"
)

type ApiMgr struct {
	endpoints         map[string][]string
	resource          string
	username          string
	password          string
	collections       map[string]*schema.Collection
	currentcollection string
	currentroute      string
	currentenv        string
	environment       *schema.Environment
	serviceID         string
}

//Use specifies the collection being used, passing in the endpoint and the name of the resource to use.
func (mgr *ApiMgr) Use(service string, resourceName string) (map[string]interface{}, error) {

	//find collection in database . make sure resource exists and then proceed to add the resource to the endpoints list.
	//Does not check to make sure endpoint is live or responsive.
	payload := schema.FetchResoure{}
	payload.Key = service
	payload.Resource = resourceName
	payload.ServiceID = mgr.serviceID

	resp, err := mgr.prepareRequest("POST", "/resource/fetch", payload)
	if err != nil {
		log.Printf("something went wrong %s", err)
		return nil, err
	}

	body := make(map[string]interface{})
	json.NewDecoder(resp.Body).Decode(&body)

	log.Printf("Response %v", body)

	if body["status"] == -1 {
		return body, errors.New("request failed %s may be unavailable")
	}

	return body, nil
}

func New(resource, serviceID string) *ApiMgr {
	return &ApiMgr{
		resource:  resource,
		serviceID: serviceID,
	}
}

func (mg *ApiMgr) WithBasicAuth(username, password string) *ApiMgr {
	mg.username = username
	mg.password = password
	return mg
}

func (mgr *ApiMgr) prepareRequest(method, route string, payload interface{}) (*http.Response, error) {
	jsonBytes, err := json.Marshal(payload)
	if err != nil {
		return nil, errors.New("failed to prepare request")
	}

	req, err := http.NewRequest(method, fmt.Sprintf("%s%s", mgr.resource, route), bytes.NewBuffer(jsonBytes))
	if err != nil {
		return nil, fmt.Errorf("failed to prepare request %s", err)
	}

	req.SetBasicAuth(mgr.username, mgr.password)
	client := http.Client{}
	response, err := client.Do(req)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (mg *ApiMgr) Create(payload interface{}) error {
	err := mg.CallAPI("POST", "/collection/create", payload)
	err = mg.CallAPI("POST", "/env/create", mg.environment)
	if err != nil {
		return err
	}
	return nil
}

func (mg *ApiMgr) CallAPI(method, route string, payload interface{}) error {
	resp, err := mg.prepareRequest(method, route, payload)
	if err != nil {
		log.Printf("something went wrong %s", err)
		return err
	}

	body := make(map[string]interface{})
	json.NewDecoder(resp.Body).Decode(&body)

	log.Printf("Response: %v", body)

	return err
}

func (mg *ApiMgr) NewEnv(name string) *ApiMgr {
	mg.environment = &schema.Environment{
		Name: name,
	}

	return mg
}

// Fix later
type AutoGenerated struct {
	Body struct {
		Environment struct {
			ID     string              `json:"id"`
			Name   string              `json:"name"`
			Values []*schema.EnvValues `json:"values"`
		} `json:"environment"`
	} `json:"body"`
	Status int `json:"status"`
}

func (mg *ApiMgr) FromEnv(envID, key, value string) *ApiMgr {
	payload := make(map[string]string)
	payload["id"] = envID
	resp, err := mg.prepareRequest("POST", "/env/fetch", payload)
	if err != nil {
		log.Printf("could not find referenced env %s", err)
		return mg
	}

	bud := AutoGenerated{}
	bod, err := ioutil.ReadAll(resp.Body)
	err = json.Unmarshal(bod, &bud)
	if err != nil {
		log.Printf("failed to unmarshall %s", err)
		return nil
	}

	bud.Body.Environment.Values = append(bud.Body.Environment.Values, &schema.EnvValues{
		Key:     key,
		Value:   value,
		Enabled: true,
	})

	in := schema.UpdateEnv{}
	in.Env.ID = bud.Body.Environment.ID
	in.Env.Name = bud.Body.Environment.Name
	in.Env.Values = bud.Body.Environment.Values

	res, err := mg.prepareRequest("POST", "/env/update", in)
	if err != nil {
		log.Printf("could not update referenced env")
	}

	r := make(map[string]interface{})
	json.NewDecoder(res.Body).Decode(&r)
	log.Printf("Response 2 %v", r)

	return mg
}

func (mg *ApiMgr) EnvVar(key, value string) {
	mg.environment.Values = append(mg.environment.Values, &schema.EnvValues{
		Key:   key,
		Value: value,
	})
}
